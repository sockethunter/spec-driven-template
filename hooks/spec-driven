#!/usr/bin/env bash
set -euo pipefail

FILE="${1:-}"
ROOT="${2:-}"

# ---- Configuration ----
: "${SETTING_MODEL:=haiku}"
: "${SETTING_MAX_TURNS:=10}"
: "${SETTING_DEBOUNCE_SECONDS:=8}"
: "${SETTING_MAX_LINES:=1200}"
: "${SETTING_CACHE_DIR:=.hook-cache}"
: "${SETTING_TIMEOUT:=40}"
# -----------------------------------

if [[ -z "$FILE" ]]; then
  echo "[spec_driven] File not found" >&2
  exit 2
fi

if [[ -n "$ROOT" ]]; then
  cd "$ROOT"
elif git rev-parse --show-toplevel >/dev/null 2>&1; then
  cd "$(git rev-parse --show-toplevel)"
fi

mkdir -p "$SETTING_CACHE_DIR"

# Clean up old cache files (older than 30 days)
find "$SETTING_CACHE_DIR" -name "*" -type f -not -path "*/pids/*" -mtime +30 -delete 2>/dev/null || true

LINES=$(wc -l < "$FILE" | tr -d ' ')
if [[ "$LINES" -gt "$SETTING_MAX_LINES" ]]; then
  echo "[spec_driven] Skip (too big: ${LINES} Lines > ${SETTING_MAX_LINES})"
  exit 0
fi

KEY=$(echo "$FILE" | shasum -a 256 | awk '{print $1}')
CACHE_FILE="${SETTING_CACHE_DIR}/${KEY}"
CONTENT_HASH=$(shasum -a 256 "$FILE" | awk '{print $1}')
LAST_HASH=""; LAST_TS=0
if [[ -f "$CACHE_FILE" ]]; then
  read -r LAST_HASH LAST_TS < "$CACHE_FILE" || true
fi
NOW=$(date +%s)
if [[ "$CONTENT_HASH" == "$LAST_HASH" && $((NOW - LAST_TS)) -lt $SETTING_DEBOUNCE_SECONDS ]]; then
  echo "[spec_driven] Skip (debounce & unchanged)"
  exit 0
fi

# Check if we have undocumented elements or if file changed since last successful run
if [[ "$CONTENT_HASH" == "$LAST_HASH" ]]; then
  echo "[spec_driven] Skip (file not changed since last run)"
  exit 0
fi

echo "[spec_driven] Starting Claude"

CLAUDE_BIN=$(command -v claude || true)
if [[ -z "$CLAUDE_BIN" ]]; then
  echo "[spec_driven] 'claude' not in PATH" >&2
  exit 127
fi

# Status f√ºr VSCode anzeigen
BASENAME=$(basename "$FILE")

# VSCode Title Update √ºber Settings
update_vscode_title() {
  local status="$1"
  
  local settings_file=".vscode/settings.json"
  
  if [[ -n "$status" ]]; then
    local title
    if [[ "$status" == "ready" ]]; then
      title="Spec-driven ready"
      echo "üìä $title"
    elif [[ "$status" == "‚ö° RUNNING" ]]; then
      title="Spec-driven running"
      echo "üìä $title"
    else
      title="Spec-driven $status"
      echo "üìä $title"
    fi
    
    # VSCode Settings dynamisch anpassen
    if [[ -f "$settings_file" ]]; then
      # Backup original settings
      if [[ ! -f "${settings_file}.backup" ]]; then
        cp "$settings_file" "${settings_file}.backup"
      fi
      
      # Add window.title to settings
      local temp_file=$(mktemp)
      jq --arg title "$title" '. + {"window.title": ("${dirty}${activeEditorShort}${separator}${rootName}${separator}" + $title)}' "${settings_file}.backup" > "$temp_file" && mv "$temp_file" "$settings_file"
    fi
  else
    # Restore original settings
    if [[ -f "${settings_file}.backup" ]]; then
      mv "${settings_file}.backup" "$settings_file"
    fi
  fi
}

update_vscode_title "ready"
echo "[spec_driven] üöÄ START: $BASENAME (Modell: $SETTING_MODEL, turns=$SETTING_MAX_TURNS)"

PROMPT=$(cat <<'EOF'
üìå Prompt (for Claude):

You will soon receive a Markdown file. Please analyze it thoroughly and derive concrete tasks from it.

üîß Your Task:
	‚Ä¢	Read the Markdown file carefully.  
	‚Ä¢	Summarize all relevant points as actionable tasks.  
	‚Ä¢	Ignore irrelevant text (e.g., introductions or acknowledgements).  
	‚Ä¢	Pay attention to headings, lists, instructions, checklists, and descriptive sections.  
	‚Ä¢	Where possible, group similar tasks or organize them by topic.

üß† Output Format:
Return the tasks in the following format:

## Task Overview
- [ ] Task 1  
- [ ] Task 2  
- [ ] ‚Ä¶

Where possible, use short, clear descriptions per task (approx. 1 sentence).
EOF
)
PROMPT="${PROMPT}

The Markdown file is located here: ${FILE}  
Write the tasks to: docs/Tasks.md."

START_TS=$(date +%s)
echo "[spec_driven] ‚ö° RUN: $BASENAME ($(date '+%H:%M:%S'))"
echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

(
  exec "$CLAUDE_BIN" -p \
    --model "$SETTING_MODEL" \
    --permission-mode acceptEdits \
    --allowedTools Edit Read Write MultiEdit \
    --max-turns "$SETTING_MAX_TURNS" \
    <<< "$PROMPT"
) &
CLAUDE_PID=$!

# Update status after PID is saved
update_vscode_title "‚ö° RUNNING"

(
  sleep "$SETTING_TIMEOUT"
  if kill -0 "$CLAUDE_PID" 2>/dev/null; then
    echo "[spec_driven] TIMEOUT (${SETTING_TIMEOUT}s) ‚Üí SIGTERM"
    kill -TERM "$CLAUDE_PID" 2>/dev/null || true
  fi
  sleep 2
  if kill -0 "$CLAUDE_PID" 2>/dev/null; then
    echo "[spec_driven] TIMEOUT escalate ‚Üí SIGKILL"
    kill -KILL "$CLAUDE_PID" 2>/dev/null || true
  fi
) & WATCHDOG_PID=$!

wait "$CLAUDE_PID"
STATUS=$?

kill "$WATCHDOG_PID" 2>/dev/null || true

echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
END_TS=$(date +%s)
DUR=$((END_TS - START_TS))

if [[ $STATUS -eq 0 ]]; then
  NEW_HASH=$(shasum -a 256 "$FILE" | awk '{print $1}')
  echo "$NEW_HASH $NOW" > "$CACHE_FILE"
  update_vscode_title "‚úÖ DONE"
  echo "[spec_driven] ‚úÖ DONE: $BASENAME (${DUR}s)"
  sleep 1
  update_vscode_title ""  # Back to normal
else
  update_vscode_title "‚ùå ERROR"
  echo "[spec_driven] ‚ùå ERROR: $BASENAME (Exit $STATUS, ${DUR}s)"
  sleep 2
  update_vscode_title ""  # Back to normal
  exit $STATUS
fi

cd $ROOT
./hooks/spec-driven-impl ${ROOT}/docs/Tasks.md ${ROOT}
